<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
















  
  <meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">

  
  <meta content="text/html; charset=ISO-8859-1">

  
  <meta name="AUTHOR" content="Craig Miller">

  
  <link rel="stylesheet" type="text/css" href="el.css"><title>expect-lite Doc</title>
  

  
  
  <meta content="Craig Miller" name="author"></head><body>
<table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">

  <tbody class="page">
    <tr>
      <td style="vertical-align: top; width: 35%;"><br>
      <div style="text-align: center;"><a href="index.html"><img style="border: 0px none ; font-weight: bold; width: 200px; height: 213px;" alt="greater than" src="keycap_200.jpg"></a><br>
      <h1>expect-lite</h1>
      <br>
      <h2>Automation for the rest of us</h2>
      </div>
      <script type="text/javascript" src="js-side-menu.js"></script> <noscript><br>
Please Enable Javascript
to see Features, Downloads, and Docs </noscript> </td>
      <td style="vertical-align: middle; width: 1px;"> <img src="vbar.gif" style="width: 1px; height: 22000px;"></td>
      <td style="vertical-align: top; width: 5%;"><br>
      </td>
      <td style="vertical-align: top;"><!--- Begin of Right Column Content ---><br>
      <h2 style="text-align: center;"><big>List of Features</big><br>
      </h2>
Expect-lite has many features which make expect-style script writing
easy. <br>
      <br>
      <span style="font-weight: bold;">Easy of Use</span><br>
      <ul>
        <li><a href="expect-lite_doc.html#special_characters"><span style="font-weight: bold;">Simplicity</span> </a>using
one
character for send and expect '&gt;' '&lt;' <br>
This creates many lines of expect with minimal "code" (<a href="#special_characters">table of interpreted characters</a>)<br>
        </li>
        <li><a href="expect-lite_doc.html#executable_script"><span style="font-weight: bold;">Scripts
can
be executable</span></a>
with the standard #!/usr/bin/env expect-lite line <span style="background-color: rgb(255, 255, 102);"></span></li>
        <li><a href="expect-lite_doc.html#include_files"><span style="font-weight: bold;">Include
mechanism</span></a> to read
other script files (sourcing)</li>
        <li><span style="background-color: rgb(255, 255, 102);"><span style="background-color: white;"><a style="font-weight: bold;" href="expect-lite_doc.html#directive_managing_logging">Color</a>
enhances output, differentiates log messages</span></span></li>
        <li><a href="expect-lite_doc.html#Automatic_Login_"><span style="font-weight: bold;">Automatic
login</span></a> to remote
host (supporting telnet, ssh with password, and ssh with keys)</li>
        <li><a href="#examples"><span style="font-weight: bold;">Examples</span></a>&nbsp;
showing complex actions easily scripted</li>
        <li><a style="font-weight: bold;" href="#ipv6_support">IPv6</a><span style="font-weight: bold;"> </span>Full Support <span style="background-color: yellow;">new in 4.2.2</span></li>

      </ul>
      <span style="font-weight: bold;">Variables<br>
      </span>
      <ul>
        <li style="font-weight: bold;"><a href="expect-lite_doc.html#variables">Static
and
Dynamic
Variables</a> <span style="font-weight: normal;">with
math
functions and pseudo arrays</span><br>
        </li>
        <li><a href="expect-lite_doc.html#constants"><span style="font-weight: bold;">Constants</span></a>,
passed on the
command line or set as environment variables, which override variables
in the script</li>
        <li style="font-weight: bold;"><a href="expect-lite_doc.html#bash_shell">Leverages
Bash
shell</a> <span style="font-weight: normal;">passing unknown variables
to the shell</span><br>
        </li>
      </ul>
      <span style="font-weight: bold;">Programmatic<br>
      </span>
      <ul>
        <li><a href="expect-lite_doc.html#regex_in_expect-lite"><span style="font-weight: bold;">Regular
expression</span></a>
(regex) evaluation in expected results</li>
        <ul>
          <li><a href="expect-lite_doc.html#expect_no_regex">Non-Regex
evaluation</a> also available in expected results&nbsp;<span style="background-color: rgb(255, 255, 102);"></span></li>
        </ul>
        <li><a href="expect-lite_doc.html#conditional"><span style="font-weight: bold;">Conditional
Branching</span></a> a
if/then/else with a c-like syntax</li>
        <ul>
          <li><a href="#undefined_var_conditional">Testing undefined variables</a> useful for setting default variable values <span style="background-color: yellow;"></span><br>
          </li>
        </ul>

        <li><a href="expect-lite_doc.html#looping"><span style="font-weight: bold;">Simple
looping</span></a>
using
conditional branching, a repeat loop can be constructed with infinite
loop protection</li>
        <li><a style="font-weight: bold;" href="#code_blocks">Code Blocks</a> group lines of script for conditionals and while loops&nbsp;<span style="background-color: yellow;"></span></li>

      </ul>
      <span style="font-weight: bold;">Advanced</span><br>
      <ul>
        <li><a href="expect-lite_doc.html#executable_script"><span style="font-weight: bold;"></span></a><a href="expect-lite_doc.html#directive_fork"><span style="font-weight: bold;">Multiple
Sessions</span></a>
enabling interaction with a client and a server in one script <br>
        </li>
        <li><a href="expect-lite_doc.html#not_expect"><span style="font-weight: bold;">Not
Expect</span></a>
- a feature to
look for unexpected text/strings</li>
        <li><a href="expect-lite_doc.html#directives"><span style="font-weight: bold;">Directives</span></a> controls behaviour of
expect-lite, enabling/disabling logging, shell, fail-script...</li>
        <li><a href="expect-lite_doc.html#user_defined_prompt"><span style="font-weight: bold;">User
defined
prompt</span></a>
allows interaction with a wider range of hosts (routers, switches, etc)
          <br>
        </li>
        <li><a href="expect-lite_doc.html#embedded_expect"><span style="font-weight: bold;">Embedded
Expect</span></a> - using
native expect embedded in an expect-lite script</li>
        <li><a href="expect-lite_library.html"><span style="font-weight: bold;">Library mode</span></a> use expect-lite as
a TCL package&nbsp;<span style="background-color: rgb(255, 255, 102);"></span> <br>
</li>
        <li><a href="#script_help"><span style="font-weight: bold;">User Defined Script Help</span></a> makes your script more user-friendly <span style="background-color: yellow;">new in 4.3.0</span></li>

      </ul>
      <span style="font-weight: bold;">Debugging<br>
      </span>
      <ul>
        <li><a href="expect-lite_doc.html#instant_interact"><span style="font-weight: bold;">Instant-Interact</span></a>
empowers on the spot debugging without having to set breakpoints<span style="background-color: rgb(255, 255, 102);"></span></li>
        <li><span style="background-color: rgb(255, 255, 102);"><span style="background-color: white;"></span></span><span style="background-color: rgb(255, 255, 102);"><span style="background-color: white;"><a href="expect-lite_tips.html#ide"><span style="font-weight: bold;">Powerful Integrated Debugger</span></a> set
breakpoints, step/skip, copy/paste lines into running script&nbsp; <br>
          </span></span></li>
      </ul>
      <span style="font-weight: bold;"></span><br>
      <hr style="width: 75%; height: 2px;"><br>
      <h2 style="text-align: center;"><big><a name="intro"></a>Introduction</big></h2>

      <h2><a name="Automatic_Login_"></a>Automatic
Login<br>
      </h2>
expect-lite was born into a multi-host environment, and therefore
there was the early requirement to remote login to a host (usually a
Linux machine) allocated by a sharing facility such as the commercial
package, LSF. Therefore, a remote host must be specified on the command
line where the script will wake up and begin executing. <br>
      <br>
Three methods of remote login are supported:<br>
      <ul>
        <li>telnet</li>
        <li>ssh with password</li>
        <li>ssh with keys (no password)</li>
      </ul>
ssh with keys is the preferred method, since no password is required,
however this requires some environment setup before hand.<br>
      <br>
Even
when no remote host is required, it is best to log into the localhost,
since the underlying Expect has problems with synchronization (between
send and expect strings) when a remote host is not specified. The
provided shell script 'setup_local_ssh.sh' will setup the localhost
with ssh keys. It is only necessary to run it once:<br>
      <pre>./setup_local_ssh.sh</pre>
Based on the command line arguments passed, expect-lite will do the
following:<br>
      <ul>
        <li>Automatically log into the remote host via telnet or
ssh
(if ssh
keys have been
previously setup)</li>
        <li>Change directory to the passed directory (if included)</li>
      </ul>
      <br>
In the following example of expect-lite: <br>
      <pre>./expect-lite remote_host=remote-host-018 cmd_file=basic_ping_test.elt user_dir=/etc</pre>
Or the shorter version<br>
      <pre>./expect-lite r=remote-host-018 c=basic_ping_test.elt d=/etc</pre>
Or the shorter version which is more linux like<br>
      <pre>./expect-lite -r remote-host-018 -c basic_ping_test.elt -d /etc</pre>
      <br>
expect-lite will log into remote-host-018, change directory to /etc/
and
begin to send commands from basic_ping_test.elt to the remote-host. The
parameters of remote_host and cmd_file are required, as expect-lite
must know what host to log into, and what script (aka command file) to
run.<br>
      <br>
      <span style="font-weight: bold;"><a name="env_vars"></a>Environment
Variables</span><br>
      <br>
The
following environment variables permit the customization of expect-lite
without having to edit the expect-lite script itself. It is recommended
that commonly used environment variables be placed in the .bashrc or
.cshrc file where they will be automatically set upon login.<br>
      <ul>
      </ul>
      <dl>
        <dd>
          <table style="text-align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">
            <tbody>
              <tr>
                <td style="vertical-align: top; font-weight: bold; background-color: rgb(204, 204, 204);">Env
Var<br>
                </td>
                <td style="vertical-align: top; font-weight: bold; background-color: rgb(204, 204, 204);">Description<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">EL_REMOTE_HOST<br>
                </td>
                <td style="vertical-align: top;">Name or IP of remote
host<br>
                </td>
              </tr>
              <tr>
                <td>EL_CMD_FILE</td>
                <td>Name of expect-lite script to run</td>
              </tr>
              <tr>
                <td>EL_USER_DIR</td>
                <td>Change to this directory upon login before
executing script</td>
              </tr>
              <tr>
                <td>EL_CONNECT_METHOD</td>
                <td>The method expect-lite uses to connect to remote
host. Valid options are: none|telnet|ssh|ssh_key <br>
Default is none</td>
              </tr>
              <tr>
                <td>EL_CONNECT_USER</td>
                <td>User name to use for login on remote host
(telnet|ssh)</td>
              </tr>
              <tr>
                <td>EL_CONNECT_PASS</td>
                <td>Password to use for login on remote host
(telnet|ssh)</td>
              </tr>
              <tr>
                <td>EL_DELAY_WAIT_FOR_HOST</td>
                <td>Delay
(in ms) to wait for host in Not Expect, and Dynamic Var Capture. 100 ms
is a good value for a local LAN, 200 ms if running across high speed
internet</td>
              </tr>
              <tr>
                <td>EL_*</td>
                <td>Any other shell environment variables starting with
EL_ will become constants</td>
              </tr>
            </tbody>
          </table>
        </dd>
      </dl>
      <br>
      <h2><a name="special_characters"></a>Special
Character Sequences<br>
      </h2>
Although basic expect-lite scripts can be created
by simply cutting and pasting text from a terminal window into a
script, and adding '&gt;' '&lt;' characters, such as:<br>
      <pre>&gt;pwd<br>&lt;/home/user</pre>
Much more functionality is available. expect-lite interprets
punctuation characters at the
beginning of each line in the script:<br>
      <dl>
        <dd>
          <table style="text-align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">
            <tbody>
              <tr>
                <td style="vertical-align: top; font-weight: bold; background-color: rgb(204, 204, 204);">Char<br>
                </td>
                <td style="vertical-align: top; font-weight: bold; background-color: rgb(204, 204, 204);">Action<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">&gt;<br>
                </td>
                <td style="vertical-align: top;">send
string to
the remote
host</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">&gt;&gt;<br>
                </td>
                <td style="vertical-align: top;">send
string to
remote host,
without waiting for prompt
(see <a href="#implied_prompt">implementation details</a>)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">&lt;<br>
                </td>
                <td style="vertical-align: top;">string/regex<span style="font-weight: bold;"> MUST</span> be
received from the remote host in the alloted timeout or the script will
FAIL! (see <a href="#test_failure">test failure</a>)</td>
              </tr>
              <tr>
                <td>&lt;&lt;</td>
                <td>literal string MUST be received (similar to
'&lt;' without regex evaluation)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">-&lt;<br>
                </td>
                <td style="vertical-align: top;">if
string/regex<span style="font-weight: bold;"> IS</span>
received from the remote host the script will
FAIL! (see <a href="#not_expect">Not Expect</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">#<br>
                </td>
                <td style="vertical-align: top;">used to
indicate comment
lines,
and have no effect</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">;<br>
                </td>
                <td style="vertical-align: top;">are also
used
to indicate
comment lines, but are printed to
stdout (<a href="#unsynchronized_messages">for logging</a>)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">;&lt;colour&gt;<br>
                </td>
                <td style="vertical-align: top;">add
custom colour comment lines, colour may be blue,&nbsp; ltblue,&nbsp;
gray,&nbsp; ltgray,&nbsp; cyan,&nbsp; black, pink, purple, red, green,
yellow<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">;;<br>
                </td>
                <td style="vertical-align: top;">similar
to
above, but no
extra newlines are printed (useful for printing script help)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">;;;<br>
                </td>
                <td style="vertical-align: top;">Marks the beginning and end of user defined script help (see <a href="#script_help">script help</a>)<br>
                </td>
              </tr>
<tr>
                <td style="vertical-align: top;">@num<br>
                </td>
                <td style="vertical-align: top;">changes
the
expect timeout
to num of seconds<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">$var=<br>
                </td>
                <td style="vertical-align: top;">static
variable
assignment at script
invocation (see <a href="#variables">variables</a>
for
details)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">+$var=<br>
                </td>
                <td style="vertical-align: top;">dynamic
variable
assignment&nbsp; (see <a href="#variables">variables</a>)</td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">+$var</td>
                <td align="undefined" valign="undefined">increment
value of
$var by 1 decimal (see <a href="#looping">repeat loop</a>)</td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">-$var</td>
                <td align="undefined" valign="undefined">decrement
value of
$var by 1 decimal</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">=$var<br>
                </td>
                <td style="vertical-align: top;">math
functions,
perform
bitwise and arithmetic operations:&nbsp; &lt;&lt;
&gt;&gt; &amp; | ^ *
/ % + - (see <a href="#math_variables">math functions</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">!<br>
                </td>
                <td style="vertical-align: top;">indicates
an
embedded expect
line (see <a href="#embedded_expect">embedded
expect</a>)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">?<br>
                </td>
                <td style="vertical-align: top;">c-style
if/then/else in the
format ?cond?action::else_action (see <a href="#conditional">conditionals</a> and <a href="#code_block_conditional">code blocks</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">[ &lt;test&gt;<br>
]<br>
                </td>
                <td style="vertical-align: top;">while loop (see <a href="#while_loop">code blocks</a>)<br>
                </td>
              </tr>
<tr>
                <td style="vertical-align: top;">%<br>
                </td>
                <td style="vertical-align: top;">label -
used
for jumping to
labels (see <a href="#conditional">conditionals</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">~filename<br>
                </td>
                <td style="vertical-align: top;">includes
a
expect-lite
automation file, useful
for creation of common variable files, or 'subprograms/subroutines'</td>
              </tr>
            </tbody>
          </table>
        </dd>
      </dl>
      <br>
      <ul>
      </ul>
In addition to the above special characters, blank lines or lines
starting with any non-special character are allowed to make the script
file more readable. <br>
      <br>
Sometimes control characters must be sent. Currently all
control characters are supported (from ^@ to ^\):<br>
      <ul>
        <li>^C or break, when it is desired to stop a running
program
e.g.
&gt;^C or &gt;&gt;^C</li>
        <li>^] or escape from telnet, e.g. &gt;^] This will
bring
the
script
to the telnet prompt, then use: &gt;quit</li>
        <li>^&lt;any char&gt; will send a control
character to
the
remote-host,
such as ^D to logout</li>
      </ul>
Control characters must be the first two characters on the line
(e.g.[^][A-Z]). The sequence of ^C anywhere else in the line will not
be interpreted as a control-C, but rather the two characters '^' 'C'.<br>
      <br>
      <a name="directives_table"></a>Lastly, any line beginning with an
asterisk '*' will be interpreted as
an expect-lite directive. Directives change the behaviour of
expect-lite.<br>
      <dl>
        <dd>
          <table style="text-align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">
            <tbody>
              <tr>
                <td style="vertical-align: top; color: rgb(204, 204, 204); background-color: rgb(204, 204, 204);"><br>
                </td>
                <td style="vertical-align: top; color: rgb(204, 204, 204); background-color: rgb(204, 204, 204);"><span style="color: rgb(0, 0, 0); font-weight: bold;">Expect-lite
Directives</span><br>
                </td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">*~filename</td>
                <td align="undefined" valign="undefined">Include
a fail
script, which expect-lite runs only if the main script fails (see <a href="#fail_script">fail script</a>)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">*/prompt/<br>
                </td>
                <td style="vertical-align: top;">Set
a user defined prompt (see <a href="#user_defined_prompt">user
defined
prompt</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">*TERM<br>
                </td>
                <td style="vertical-align: top;">Immediately
terminates script, but returns 0 (pass) (see <a href="#directive_term_fail">stopping execution early</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">*FAIL<br>
                </td>
                <td style="vertical-align: top;">Immediately
fails script, and returns 1 (fail) (see&nbsp;<a href="#directive_term_fail">stopping execution early</a>)<br>
                </td>
              </tr>
              <tr>
                <td>*NOFAIL</td>
                <td>Script will run to completion, and returns 1, if
failure occured during execution, or 0, if pass</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">**SHELL=&lt;shell&gt;<br>
                </td>
                <td style="vertical-align: top;">Configuration
directive which sets the shell immediately after automatic login to
remote host (see <a href="#directive_shell">setting the
shell</a>)<br>
                </td>
              </tr>
              <tr>
                <td style="vertical-align: top;">*INTERACT<br>
                </td>
                <td style="vertical-align: top;">Places
user in
interact
mode, which pauses the script and turns control of the keyboard over to
the user (see <a href="./expect-lite_tips.html#interact">Tips
&amp;
Techniques: Interact</a>)<br>
                </td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">*FORK
&lt;session&gt;</td>
                <td align="undefined" valign="undefined">Multiple
session support.
Directs expect-lite to open a new session and spawns a newshell (see <a href="#directive_fork">multiple sessions</a>)</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">*SHOW VARS<br>
                </td>
                <td style="vertical-align: top;">Debug
information, displays
all expect-lite variables. Can be used in interact mode.</td>
              </tr>
              <tr>
                <td>*EOLS LF<br>
*EOLS CRLF</td>
                <td>Controls end of line sequence sent to remote
host, either line feed, or carriage return &amp; line feed.</td>
              </tr>
              <tr>
                <td style="vertical-align: top;">*INFINITE_LOOP
&lt;N&gt;<br>
                </td>
                <td style="vertical-align: top;">Sets/resets the
infinite loop protection value, which is a total count of all loops in
script. Default is 5000<br>
                </td>
              </tr>
              <tr>
                <td style="background-color: rgb(204, 204, 204);" align="undefined" valign="undefined"><br>
                </td>
                <td style="background-color: rgb(204, 204, 204);" align="undefined" valign="undefined"><span style="color: rgb(0, 0, 0); font-weight: bold;">Logging
Directives</span></td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">*INFO <br>
*NOINFO</td>
                <td align="undefined" valign="undefined">Enable/disable
informational messages (see <a href="#directive_managing_logging">managing
logging</a>)</td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">*WARN <br>
*NOWARN</td>
                <td align="undefined" valign="undefined">Enable/disable
warning messages</td>
              </tr>
              <tr>
                <td align="undefined" valign="undefined">*DEBUG <br>
*NODEBUG</td>
                <td align="undefined" valign="undefined">Enable/disable
debug
messages</td>
              </tr>
              <tr>
                <td>*NOCOLOR</td>
                <td>Disables color output, best when logging
output</td>
              </tr>
              <tr>
                <td>*TIMESTAMP &lt;ISO|YMD|DMY|MDY&gt;</td>
                <td>Prints Date and Timestamp for each command sent,
ISO is default</td>
              </tr>
              <tr>
                <td>*NOTIMESTAMP</td>
                <td>Disables timestamp printing</td>
              </tr>
            </tbody>
          </table>
        </dd>
      </dl>
      <br>
      <h2><a name="ipv6_support"></a>IPv6 Support</h2>
expect-lite is an application, and will use communications
protocols such as telnet and ssh to connect to a remote host. If telnet or ssh is IPv6 enabled, then expect-lite can/will
use it.<br>
      <br>
However, it may be important to include IPv6 addresses in expect-lite
scripts. expect-lite now fully supports IPv6 addresses including short
hand notation with double colons, e.g. 2001:db8::dead<br>
      <br>
Care has been taken to have expect-lite do the right thing with IPv6
addresses, however, it may be necessary to be more explicit when using
conditionals (if/then/else), see <a href="#conditional_ipv6">conditionals and IPv6</a>.<br>
      <h2><a name="tips"></a>General Tips for
writing scripts</h2>
Here are some simple tips when script writing:<br>
      <ul>
        <li>Use reasonable timeouts, if 30 seconds is needed to
get a
response, set the timeout at 45 or 60 seconds, not 600.</li>
        <ul>
          <li>There is no cost to changing the timeout, timeout
values
can
also be variables<br>
          </li>
        </ul>
        <li>Beware of expect-lite using regex, when creating
lines
like:
&lt;0.005 secs (5 micro secs)</li>
        <ul>
          <li>The parentheses is used by the regex engine,
instead
escape
these characters: &lt;0.005 secs \(5 micro secs\) (see <a href="#regex_in_expect-lite">Use of Regex in expect-lite</a>)</li>
          <li>or use '&lt;&lt;' which does not use regex,
and
does not require escaping: &lt;&lt;0.005 secs (5 micro secs)
(see <a href="#expect_no_regex">using non-regex evaluation</a>)</li>
        </ul>
        <li>Use the expect character '&lt;' or
'&lt;&lt;'
often. Check for valid
results
when possible. A script which expects nothing will never fail! (see <a href="#test_failure">Test Failure</a>)</li>
        <li><a name="printable_comments"></a>Use
printable comments ';' &nbsp;and ';;' often. Think of it as
writing
a note to oneself, it will make reading log files much easier. As of
version 3.7.0 printable comments will be coloured <span style="color: rgb(51, 51, 255);">blue</span> (this is
user configurable).</li>
        <li>Variable assignments use no spaces e.g. $var=value. Note no spaces
around the equals sign, this permits leading spaces in the value such
as $var=&nbsp; myvalue</li>

      </ul>
      <h2><a name="debugging"></a>Debugging
Expect-lite Scripts</h2>
Expect-lite was written to permit quick and easy automation of
repetitive tasks. However, sometimes a little additional debugging is
required. <br>
      <br>
      <a name="instant_interact"></a>Instant-Interact
(as
of version 3.5.0) or instant breakpoint,
provides instant debugging assistance. Pressing
^\ (control+backslash) will force expect-lite to drop into interact
mode, a mode which turns control of the keyboard over to the user, so
that one may type directly to the process on the remote host. To return
to the script, type '+++' (three pluses). During interactive mode,
timeouts do not apply, *NOFAIL is automatically enabled, and the script
will wait indefinitely for the
user to exit this debugging mode. Switching between multiple sessions
(see <a href="#directive_fork">*FORK</a>) is
possible via typing the
*FORK command in interact mode (see <a href="#directive_fork_debugging">*FORK
debugging</a>).<br>
      <br>
Additionally, the interact mode (or Integrated Debugger Environment)
performs three primary functions: 1) connecting the user to the remote
host or device under test, 2) monitoring special commands prefaced with
the escape key for stepping, and other functions, and 3) the debugger
will allow expect-lite script lines to be executed by either typing
directly or pasting them into the IDE.<br>
      <br>
See the <a href="expect-lite_tips.html">Tips and
Techniques Guide</a>
for additional expect-lite script debugging information.<br>
      <br>
      <br>

      
      <hr style="width: 75%; height: 2px;"><br>

      <h2 style="text-align: center;"><big><a name="reference"></a>Reference</big></h2>


      <h2><a name="regex_in_expect-lite"></a>Use
of
Regex in expect-lite</h2>
Support of regular expressions in expect-lite are limited by:<br>
      <ol>
        <li>Support of regex in standard expect (e.g. including
anchors,
char-classes and repeats)<br>
        </li>
        <li>Support of regex meta characters (e.g. \t \n \d)</li>
        <li>Expect-lite only evaluates lines using regex which
begin
with
'&lt;'&nbsp; '-&lt;' and '+' (dynamic variables)<br>
        </li>
      </ol>
As an example, a range of numbers is valid for an IP address.
The following would permit the last octet of the IP address to be 2
digits, but not 3.<br>
      <pre>&gt; /sbin/ifconfig eth0<br>&lt;inet addr:10\.29\.200\.\d\d[ ]</pre>
The periods are preceded by a backslash to indicate to regex that a
period must be returned rather than the regex dot '.' which indicates
any character. The \d indicates any single digit.<br>
      <br>
Because regex is always enabled for expected results, some 'escaping'
of characters must be done when using '&lt;'. The following
characters
must be escaped with a backslash to convey their literal meaning:<br>
      <a name="escaped_regex"></a><br>
      <table style="text-align: left; width: 35%; margin-left: 40px;" border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; font-weight: bold;">Example<br>
            </td>
            <td style="vertical-align: top; font-weight: bold;">Escaped<br>
            </td>
            <td style="vertical-align: top; font-weight: bold;">Character<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top; width: 20%;">(abc)</td>
            <td style="vertical-align: top; width: 20%;">\(abc\)</td>
            <td style="vertical-align: top;">parenthesis</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">[abc] <br>
            </td>
            <td style="vertical-align: top;">\[abc\]&nbsp; <br>
            </td>
            <td style="vertical-align: top;"> square
brackets</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">\ <br>
            </td>
            <td style="vertical-align: top;">\\ <br>
            </td>
            <td style="vertical-align: top;">backslash</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">.</td>
            <td style="vertical-align: top;">\. <br>
            </td>
            <td style="vertical-align: top;">period</td>
          </tr>
          <tr>
            <td style="vertical-align: top;">$</td>
            <td style="vertical-align: top;">\$ <br>
            </td>
            <td style="vertical-align: top;">dollar
sign</td>
          </tr>
          <tr>
            <td>+</td>
            <td>\+</td>
            <td>plus</td>
          </tr>
          <tr>
            <td>*</td>
            <td>\*</td>
            <td>asterisk (or star)</td>
          </tr>
          <tr>
            <td>|</td>
            <td>\|</td>
            <td>pipe</td>
          </tr>
        </tbody>
      </table>
      <br>
      Regex is a very powerful syntax unto itself, and one can create quite complex regex strings. There is an excellent <a href="http://www.addedbytes.com/cheat-sheets/regular-expressions-cheat-sheet/">regex cheat </a>sheet
created by David Child, which is very helpful. That said, one does not
need to be a regex expert to use expect-lite, it is possible to use
regex in a very basic way, see examples for more info.<br>
      <h3><a name="expect_no_regex"></a>Using
&lt;&lt; for non-regex evaluation</h3>
There
are times when the use of regex is not desired, or 'escaping'
characters is burdensome. As of version 3.6.0, expect lines can begin
with '&lt;&lt;' which will not use regex, but rather literal
evaluation
of expected results.&nbsp;<br>
      <br>
      <span style="font-weight: bold;"><a name="handling_xml_tags"></a>Handling
HTML/XML Tags in
expect lines</span><br>
The &lt;&lt; may cause a backward compatibility problem, if the
script was expecting an HTML tag, such as<br>
      <pre>&gt;grep body my_html_file.html<br>&lt;&lt;body.+&gt;</pre>
In
the above example, the script is expecting a body tag with 1 or more
characters between body and the closing greater-than of the tag.
However the new feature will not interpret this line as regex, but
rather interpret the beginning of the line as &lt;&lt;, and
evaluate it
as a literal. The method to force expect-lite to evaluate the line as
regex, is to change the line is slightly:<br>
      <pre>&gt;grep body my_html_file.html<br>&lt;[&lt;]body.+&gt;</pre>
By
making the first expected character as a regex character class, it
signals to expect-lite that this line should be evaluated as regex,
rather than a literal.<br>
      <br>
      <h2><a name="variables"></a>Using
Variables</h2>
Expect-lite supports two types of variables:<br>
      <ul>
        <li>Static, which are bound at invocation<br>
        </li>
        <li>Dynamic, which are bound during execution of the
script<br>
        </li>
      </ul>
Lines starting with a '$' indicate variables which are assigned and set
at script invocation, and therefore are static. In expect-lite variable
names will always be preceded with a '$'.<br>
      <br>
Sometimes it is desirable to bind a variable during the execution of
the script. Dynamic variables fill this need by utilizing Expect's
built-in regex capture mechanism. Only the portion of the match inside
the parenthesis will be bound to the variable. The format of the line
is as follows: <br>
      <pre>+$somevar=text that is not put into the var (text which is put into the var)</pre>
      <br>
Dynamic Variables are always bound to Expect output, meaning text which
is returned from the remote host. Therefore something must be sent to
the remote host, before text can be returned. A typical usage would be:<br>
      <pre>&gt; command<br>+$myvar=command output (capture value) more command output</pre>
      <br>
If the value of the var is successfully captured then expect-lite will
print:<br>
      <pre>Assigned Var:somevar=sometext which is put into the var</pre>
      <br>
If, however the dynamic var is not successfully captured, expect-lite
will print:<br>
      <pre>Assigned Var:somevar=__NO_STRING_CAPTURED__</pre>
Avoid using an overly general capture as it will tend to capture too
much, or the wrong info. e.g:<br>
      <pre>&gt; command<br>+$myvar=\n(.*)<br></pre>
Instead use a specific capture when possible. When capturing
the current directory, the current directory will always start with
'/', and the path will
be made up of a known character set:<br>
      <pre>&gt; echo $PWD<br>+$mypwd=\n(/[a-zA-Z0-9/\-_]+)<br></pre>
      <br>
Expect-lite will print to stdout the value of the assigned variable,
assisting the script writer in understanding the value that is bound to
the variable during runtime. The value of "__NO_STRING_CAPTURED__"
indicates that the
regex pattern used did not match the return data. It is best to start
using this feature with short scripts targeted at capturing the desired
information. <a href="#dyn_var_example">Examples</a>
can be found in
the example section of this document.<br>
      <br>
      <h3><a name="math_variables"></a>Math
Functions with Variables<br>
      </h3>
There are times when writing a script it may be necessary to perform
arithmetic or bitwise operations, also known as math functions.
Expect-lite inherits expect/tcl math functions and natively supports
math/bitwise operations on a variable, using the following slightly odd
notation:<br>
      <pre>$myvar=1<br>=$myvar + 2 * 10<br></pre>
In the above example, 2 will be multiplied by 10 and added to value of
$myvar (1). The result of 21 will be placed in $myvar, overwriting the
previous value. Since multiplication has a higher precedence than
addition, (2 * 10) will be performed before the addition to $myvar. <br>
      <br>
Parenthesis may be used to enforce user defined precedence. In the
following example, the result will be 23:<br>
      <pre>$myvar=1<br>=$myvar + 2 * (10 + 1)</pre>
      <br>
Both bitwise and arithmetic operators are supported with the following
precedence (left to right):<br>
      <table style="text-align: left; width: 616px; height: 66px;" border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top;">bitwise<br>
            </td>
            <td style="vertical-align: top;">&lt;&lt;
&gt;&gt; &amp; ^ | </td>
            <td style="vertical-align: top;">shift left,
shift
right, bit
and, bit exclusive or, or<br>
            </td>
          </tr>
          <tr>
            <td style="vertical-align: top;">arithmetic</td>
            <td style="vertical-align: top;">&nbsp;* /
% + -<br>
            </td>
            <td style="vertical-align: top;">multiply,
divide,
modulo, add,
subtract<br>
            </td>
          </tr>
        </tbody>
      </table>
      <br>
      <br>
If $myvar does not exist before the math function, it will be
initialized to blank and then math functions will be performed. In the
following example the result, $myvar, will be 20:<br>
      <pre>=$myvar + 2 * 10</pre>
However, realistically, only the '+' operator works as expected in the
above example. Using other operators will more than likely yield a
syntax error:<br>
      <pre>Warning: Expect-lite: Unable to interpret =$answer1 / 2 * (10 + 1) <br>syntax error in expression " / 2 * (10 + 1)": unexpected operator /</pre>
      <br>
Because of the expect/tcl inheritance of math functions, all operations
will be performed as integers (or whole numbers) unless a decimal (or
real) number is used explicitly. In the following example the result is
2.5:<br>
      <pre>$five=5<br>=$myvar + $five / 2.0<br></pre>
However, the following (because of the use of integers) example will
have the result of 3:<br>
      <pre>$five=5<br>=$myvar + $five / 2<br></pre>
      <br>
Math functions can be used with static and dynamic variables.<br>
      <br>
      <h3><a name="pseudo_arrays"></a>Pseudo
Arrays</h3>
Expect-lite supports pseudo arrays, which are different from a real
array (e.g. item[1], item[2],...). Pseudo arrays are made possible by
the fact that variables on the left side of the equals can be
dereferenced at assignment time. For example, below, the variable
$count will be dereferenced (or resolved) prior to assignment:<br>
      <pre>$myarray$count=some $value<br></pre>
When placed in a loop with a looping variable of $count, a pseudo array
of $myarray1, $myarray2, $myarray3,... will be created. Individual
values can be retrieved from the array by using the index (or $count)
such as $myarray23.<br>
      <br>
The pseudo array name (variable + index) must be a valid variable name,
in the set of characters (A to Z, a to z, 0 to 9, and underscore) and
no spaces.<br>
      <br>
      <h3><a name="constants"></a>Constants</h3>
Expect-lite Constants are represented as variables which are passed
into expect-lite at runtime or retrieved from environment variables
starting with EL_. Constants will override any script
variable already defined inside the script, are immutable, and
cannot be changed. Constants can be used to change the behaviour of the
script.<br>
      <br>
For example, one might invoke the following test as:<br>
      <pre>./expect-lite remote_host=remote-host-018 cmd_file=basic_ping_test.elt \<br>user_dir=/etc local_eth=eth2</pre>
      <br>
Inside the script basic_ping_test.txt any reference to $local_eth would
be set to eth2, thus allowing the script actions to be changed based on
the constant passed at invocation. Constants will override any script
variable already defined inside the script.<br>
      <br>
      <h3><a name="shell_vars"></a>Shell
Variables</h3>
Expect-lite allows the use of shell variables, which can be more
powerful than the built-in variable mechanism. However shell variables
will only be resolved by the shell. For example, assigning current
working directory to a shell var:<br>
      <pre>&gt; PWD=`pwd`<br>&gt; echo $PWD</pre>
However, the following test would fail, since $PWD is a shell variable,
not an expect-lite variable:<br>
      <pre>&gt; PWD=`pwd`<br>&gt;pwd<br>&lt; $PWD<br></pre>
Shell variables (or environment variables) must be dereferenced by the
shell. Similarly, expect-lite variables must be dereferenced by
expect-lite.<br>
      <br>
It is possible to read a shell variable into an expect-lite variable by
using the dynamic variable method:<br>
      <pre>&gt; echo $PWD<br>+$mypwd=\n(/[a-zA-Z0-9/\-_]+)<br></pre>
      <br>
      <h3><a name="undefined_vars"></a>Undefined
Variables</h3>
Since expect-lite allows the use of shell variables, it is possible
that a variable will not be known to expect-lite (but known to the
shell). Expect-lite will attempt to dereference all variables, the ones
which are not defined remain in variable form (perhaps it is a shell
variable). However, it can be useful to test if a variable is an
expect-lite variable. As of version 4.1.2, in a conditional (if
statement) undefined variables will be automatically defined as blank (
or ""). See <a href="#conditional">conditional</a> for more information.
      <h3><a name="env_vars"></a>Environment
Variables starting with EL_</h3>
When
expect-lite starts up it will automatically search the environment
variables (aka shell variables), and import any found starting with EL_
as constants. This enables setting environment variables as passwords,
or remote hosts.<br>
      <br>
For example, the environment variable EL_sudopass might be set to
"mysecret". In the script, the variable would be used as:<br>
      <pre>&gt;sudo tcpdump -i eth0<br>&lt;&lt;[sudo] password<br>&gt;&gt;$EL_sudopass</pre>
      <br>
      <h2><a name="conditional"></a>Using
Conditionals &amp; Labels<br>
      </h2>
Conditional (if/then/else) statements are natively supported in
expect-lite. The conditional uses a c-style syntax with a question mark
(?) at the beginning of the line, and double colon to indicate the else
statement, using the format ?cond?action::else_action<br>
      <br>
Although spaces are not required around the conditional characters (?
and ::), it is recommended for ease of reading. The comparison
operators are: '==',&nbsp; '!=' ,'&gt;=',&nbsp;
'&lt;=',&nbsp; '&gt;'
and '&lt;'. If the compared values can be evaluated as a numbers,
then
larger and less than will yield expected results. A simple conditional
example:<br>
      <pre>$age=56<br>? $age &gt;= 55 ? &gt;echo "freedom at 55!" :: &gt; echo "keep working!"<br></pre>
In the above example if $age is larger than or equal to 55 then the
action 'echo "freedom at 55!". If $age is less than 55 then the action
'echo "keep working!"' will be sent.<br>
      <br>
Each action or else_action is as if it began on a separate line. Since
in the above example '&gt;' is used (e.g. &gt;echo) the echo
line will
be sent to the remote host. Any expect-lite action (see <a href="#special_characters">Special Characters</a>) can
be placed after
the second question mark. For example, an <a href="#include_files">include
file</a> may be executed based on a conditional:<br>
      <pre>$platform=ppc<br>? $platform == i386 ? ~connect_i386.inc :: ~connect_ppc.inc<br></pre>
In order to make log files more understandable, a message will be
printed when a conditional is evaluated, such as:<br>
      <pre>If: expr { "ppc" == "i386" } |then ~connect_i386.inc|else ~connect_ppc.inc|result0<br></pre>
The message prints: what was evaluated (expr { "ppc" == "i386"
}),&nbsp; 'then', and 'else' actions, as well as a result (true or
false)<br>
      <br>
      <a name="conditional_ipv6"></a><span style="font-weight: bold;">IPv6 Addresses</span><br>
      <br>
Because IPv6 addresses are quite long, it is a common short hand to
represent a long string of zeros with a double colon '::', such as
2001:db8::f00d. The conditional also uses a double colon to signal the
      <span style="font-style: italic;">else</span> portion of the conditional, so what happens when:<br>
      
      <pre>$platform=ppc<br>? $platform == i386 ? $my_addr=2001:db8::f00d :: $my_addr=2001:db8::feed</pre>

      Fortunately, as of version 4.2.2, it will be as expected, $my_addr will be set to 2001:db8::feed<br>
      <br>
If in doubt, be sure to place spaces around the <span style="font-style: italic;">else</span> double colon, as spaces are never allowed in an IPv6 address.<br>
      <br>
      <a name="undefined_var_conditional"></a><span style="font-weight: bold;">Undefined variables</span><br>

      <br>
Undefined variables can be tested in a conditional (as of version
4.1.2). In and only in a conditional, variables unknown to expect-lite
are dereferenced as blank. This allows testing if a variable has been
defined such as:<br>
      <pre>$blank=<br>?if $TEST ==$blank? ; === echo this :: ; === echo that<br>?if $TEST !=  ? ; === echo this :: ; === echo that<br></pre>

      The first example, is setting a variable to blank and then
testing for equality. The second example demonstrates testing
inequality with blank. Either conditional will work, and it is a matter
of style which one is preferred.<br>
      <br>
<br>
      <a name="label"></a><span style="font-weight: bold;">Labels</span><br>
      <br>
Conditionals are limited to a single line. Sometimes this is too
limiting, as it would be nice to have several commands be executed
based on the success of a conditional. To support this, the concept of <span style="font-weight: bold;">labels</span> has been
introduced. A label
is defined as having the first character a '%'. Although the label line
itself does nothing, it provides a location to the conditional to <span style="font-style: italic;">Jump To Label</span>. The
following is a
simple example of using a conditional in conjunction with a label:<br>
      <pre>$kmodules_inserted=true<br>? $kmodules_inserted == false ? %SKIP_CHECK_KMODS<br>&gt;lsmod | grep nfs<br>&lt;nfsd<br>&lt;exportfs<br>&lt;sunrpc<br>%SKIP_CHECK_KMODS<br></pre>
When a label is the action of a conditional, there is an implied <span style="font-style: italic;">Jump to Label</span>.
Lines between the
conditional and the label will be skipped. The <span style="font-style: italic;">Jump to Label</span>
action is no longer
limited to only
jumping forward. (see <a href="#looping">Looping with
Conditionals</a>)<br>
      <br>
Multiple labels with the same name are permitted. For example, a
conditional action may be <span style="font-style: italic;">Jump
to
Label</span> %SKIP. However this is only recommended for looping (as of version 4.1.1 expect-lite searches <span style="font-style: italic;">backwards</span> for labels) Of course it is easier for the script reader if
clearer label names are used. Labels may contain spaces, as in this
example:<br>
      <pre>; === Test conditional jump to label<br>? $jump == true ?%move along, nothing to see<br>&gt;echo "1"<br>&gt;echo "2"<br>&gt;echo "3"<br>%move along, nothing to see<br></pre>
To assist reading the logs, the action <span style="font-style: italic;">Jump to Label</span> will
generate a
message to standard out (captured in the log). From the above example,
the following would be printed:<br>
      <pre>Jumping to label:%move along, nothing to see<br></pre>
      <br>
      <h2><a name="looping"></a>Looping with
Conditionals &amp; Labels<br>
      </h2>
Simple looping is now supported by allowing <span style="font-style: italic;">jump to label</span>
backwards in the script. The Repeat
Loop is the easiest loop to implement:<br>
      <pre>; ======== Incrementing Loop ========<br>$max=5<br>$count=3<br>%REPEAT_INC_LOOP<br>	&gt;echo $count<br>	# increment variable<br>	+$count<br>?if $count &lt;= $max ?%REPEAT_INC_LOOP<br></pre>
Because of <span style="font-style: italic;">jump to label</span>
default behaviour has been changed in version 4.1.1 to jump backwards, it is no longer important to assign <span style="font-style: italic;">unique</span>
looping labels. Non-looping labels, as
illustrated in the previous section, must (as of version 4.1.1) be unique.<br>
      <br>
Also included in the above example is incrementing an expect-lite
variable: +$count<br>
This will add 1 to the value of $count. If $count is not an integer,
the value of $count will remain unchanged (can't add 1 to a string).<br>
      <br>
      <a name="infinite_loop"></a>As part of the
looping
enhancement, there
is <span style="font-style: italic;">infinite loop
protection</span>.
The maximum amount of looping is&nbsp;defined with the directive
*INFINITE_LOOP N. This value is decremented with
each iteration of all loops for the entire script. Typically this would
be in the range of 1000 to 10000 to be safe. For example, if a complex
expect-lite script had 4 loops each with 100 iterations, the
_el_infinite_loop should be set larger than 400.<br>
      <br>
      <h2><a name="code_blocks"></a>Using
Code Blocks with Conditionals and While Loops<br>
      </h2>
expect-lite is a line oriented scripting language, but there are times
when it is convenient to group lines together. As of version 4.2.0, the
grouping of lines can be achieved through code blocks. A quick example
using a code block and a conditional:<br>
      <pre>; === Conditional using code block<br>? $case == true ? [<br>	&gt;echo "1"<br>	&gt;echo "2"<br>	&gt;echo "3"<br>]</pre>
      <a name="code_block_conditional"></a><span style="font-weight: bold;">Conditionals</span><br>
      <br>
A code block begins with a <span style="font-weight: bold;">[ </span>(left square bracket) and ends with a <span style="font-weight: bold;">] </span>(right
square bracket). When used with an if statement, it allows more than
one "line" to be executed based on the evaluation of the if statement.<br>
      <br>
Conditionals with code blocks also support the else construct, such as:<br>
      <pre>; === Conditional using code block as else statement<br>? $case == true ? &gt;echo "true" :: [<br>	&gt;echo "false 1"<br>	&gt;echo "false 2"<br>	&gt;echo "false 3"<br>]<br>      </pre>
Code blocks are <span style="font-weight: bold;">not</span> supported in both the then <span style="font-style: italic;">and</span> the else statements, since it appears ambiguous:<br>
      <pre>; === NOT SUPPORTED Conditional using code block then and else statement<br>? $case == true ? [ :: [<br>	&gt;echo " 1"<br>	&gt;echo " 2"<br>	&gt;echo " 3"<br>] <br></pre>
Nested code blocks can also be used. In the following example each if
statement is using a code block for the then statement, and a non-code
block for the else statement:<br>
      <pre>$test=3<br>; === nested ifs using code blocks<br>?if 1 &lt; $test ? [ :: &gt;echo "else 1"<br>	?if 2 &lt; $test ? [ :: &gt;echo "else 2"<br>		&gt;echo "if 2"<br>	]<br>]<br></pre>
      <br>
      <span style="font-weight: bold;"><a name="while_loop"></a>While Loops</span><br>
      <br>
Code blocks can also be used for quick looping using an implied while
loop construct. In the following example, the expression at the
beginning of the code block will be evaluated, if true, the lines
inside the code block will be executed. The expression (e.g. $i &lt; 3)
will be evaluated each time the code block has completed execution.
Once the
expression evaluates false (in the example $i is equal to 3), the
script will continue on the line after the bottom of the code block.<br>
      <pre>; === while loop<br>$i=0<br>[ $i &lt; 3<br>	&gt;echo "hello $i"<br>	&lt;hello $i<br>	+$i<br>]     </pre>
Nesting of while loops are also supported:<br>
      <pre>;; == Nested while loops, should repeat "hello ken" 3 times<br>;; == with 2 "bye now's inside each outer loop<br>&gt;<br>$i=0<br>[ $i &lt; 3<br>	&gt;echo "hello ken"<br>	&lt;ken<br>	$j=0<br>	[ $j &lt; 2 <br>		&gt;echo "bye now"<br>		&gt;<br>		+$j<br>	]<br>	+$i<br>]<br></pre>
Infinite loop protection applies both the "jump-to-label" method as
well as to the "while-loop" method, each iteration of the loop
decrements the infinite loop counter (default is 5000). It may
be a good idea to set the infinite loop value to something low, when
first writing while loops, just in case:<br>
      <pre>*INFINITE_LOOP 20<br></pre>
      <br>
      <h2><a name="script_help"></a>Script Help with --help -h</h2>
Once the script running, it might be handy to add help to make it more
user-friendly or refresh the mind when running the script at a later
date. As of version 4.3.0, t is possible to use the build-in script
help function which when --help or -h are typed on the command line, a
help <span style="font-style: italic;">section</span> and assigned variables will be printed.<br>
      <br>
The help section is defined in the script as a block of text which
starts with a triple-semi-colon, and ends with a triple-semi-colon,
text inside this block will <span style="font-weight: bold;">not</span> be executed by the script. For example:<br>
      <pre>;;;<br>Test: 	Test bash here doc<br>		<br>Assumptions:	bash<br>Platforms: 	anywhere bash runs<br>;;;<br></pre>

Then when running the script, with the --help or -h cli argument, the following will be printed<br>

      
      <pre>$ ./test_bash_here_doc.txt -h<br><span style="color: rgb(0, 102, 0);">Help for: ./test_bash_here_doc.txt</span><br><br>        Test:   Test bash here doc<br><br>        Assumptions:    bash<br>        Platforms:      anywhere bash runs<br><br><span style="color: rgb(0, 102, 0);">Displaying assigned variables, which can be overridden with </span><br style="color: rgb(0, 102, 0);"><span style="color: rgb(0, 102, 0);">a Constant on command line e.g var=value</span><br>        tempfile=junk<br></pre>


      The second portion of the help is a list of variables inside the script which can be overridden as constants (see <a href="#constants">Constants</a>)
on the command line. The assigned variables section of the help will
always be printed regardless if a triple-semi-colon help block has been
defined in the script. This is useful for older scripts which do not
have a triple-semi-colon help block.<br>
      <br>
Constants are a very powerful feature of expect-lite which allow the
behaviour of the script to change without having to edit the script. In
the example above, if the script were run with the following arguments:<br>
      <pre>$ ./test_bash_here_doc.txt tempfile=/tmp/mydata.txt<br>      </pre>
When the script runs, rather than creating a file called 'junk', it
will instead create a file in the /tmp directory called mydata.txt<br>
      <br>
<br>
      <h2><a name="bash_shell"></a>Expect-lite
&amp; Bash</h2>
Although not limited to working with bash, bash is invoked upon logging
into the remote host, and therefore will be discussed more here.<br>
      <br>
Since the bash shell is well documented, and supported, and therefore
can be
leveraged to assist in expect-lite's limitations such as looping and
branching (see limitations below). A simple bash loop inside
expect-lite can be created for example:<br>
      <pre>$set=1 2 3 4 5<br>&gt;for i in $set #expanded by expect-lite<br>&gt;{<br>&gt;echo $i #expanded by bash<br>&gt;}<br></pre>
In the above example, $set is an expect-lite variable, not a bash
variable. An expect-lite variable is always declared before its use
(e.g. $set= 1 2 3 4 5). If a variable cannot be dereference by
expect-lite it is passed to the shell. The loop will execute after the
final "}" line is sent to the
remote-host. Because of this "execute after" effect, an expect-lite
'&lt;' line can not be used within the bash loop. <br>
      <br>
Another example is the bash while loop:<br>
      <pre>$max=5<br>&gt;i=0<br>&gt;while [ $i -lt $max ]<br>&gt;do<br>&gt;echo $i<br>&gt;let i+=1<br>&gt;done<br></pre>
Conditionals via bash are also supported, as in this example:<br>
      <pre>$max=4<br>&gt;if [ $max -ne 5 ]; then<br>&gt;echo "max is not equal to 5"<br>&gt;else<br>&gt;echo "we have a winner"<br>&gt;fi<br></pre>
More complex bash assists can be constructed. For example, one may want
to set a looping variable based on the processor type of machine at the
time (some hosts may be faster than others). The answer is echoed, and
then captured using a dynamic variable. Note that that 'proc' is
prepended to the answer, as it enables the capture to be much more
specific.<br>
      <pre>&gt;PROC=`uname -i`<br>&gt;if [ "$PROC" == "i386" ]; then<br>&gt;echo proc20<br>&gt;else<br>&gt;echo proc100<br>&gt;fi<br>+$loop_counter=\nproc([0-9]+)<br></pre>
Note that 'proc' is outside the parenthesis, and therefore will not be
captured into the expect-lite dynamic variable $loop_counter.<br>
      <br>
      <span style="font-weight: bold;"><a name="executable_script"></a>Using
Bash to create executable expect-lite scripts</span><br>
It is possible to make expect-lite scripts executable. The old way was
to use an embedded bash script, but version 4.0.1 makes this task more
standard. Insert the following at the top of
the expect-lite script:<br>
      <pre>#!/usr/bin/env expect-lite<br></pre>
The final step to making the script executable is to use a chmod
command:<br>
      <pre>chmod 775 my_expect-lite_script.elt<br></pre>
Now the expect-lite script can be run my typing the following:<br>
      <pre>$ ./my_expect-lite_script.elt -r host-15 -u craig max_loop_count=100<br></pre>
The old bash scriptlet method can be found in
expect-lite.proj/Examples/test_masquerade.txt<br>
      <br>
      <h2><a name="include_files"></a>Include
Files</h2>
Include files are a quick way to develop script snippets which can be
included into larger scripts or to include a common variable file. When
an include file is executed, it is as if the file were just pasted into
the script file, and therefore has access to the variable space of the
main
script, and can modify that variable space as well. In this example, a
common variable file is "sourced":<br>
      <pre># Source common variable file<br>~asic_vars.inc<br></pre>
      <br>
Common functions, such as telnet'ing to the DUT, are a good use of
include files:<br>
      <pre>; === Connect to DUT <br>~dut_connect.inc<br></pre>
Include filenames can also be assigned in a variable, such that the
file names can be declared at the top of the script but used later
within
the script. For example:<br>
      <pre># Source Var file to be used<br>$asic_include=asic_vars.inc<br>...<br>~$asic_include<br></pre>
      <span style="font-weight: bold;"></span><br>
      <h2><a name="embedded_expect"></a>Embedded
Expect</h2>
There are situations when expect-lite cannot provide a solution. Rather
than force the user to abandon the simplicity of expect-lite, an
embedded expect is supported. This functionality is provided to assist
expect-lite rather than replace it. Lines beginning with '!' will be
interpreted as native expect (see <a href="#limitations_of_embedded_expect">limitations below</a>). <br>
      <br>
Embedded Expect requires the script writer to know&nbsp; native
expect.
It runs with some variable protection, and provides access to
expect-lite variables and constants, as well as the expect variable
timeout. This permits the script writer to query the timeout, store it
away, and then reset the timeout later. <br>
      <pre># Preserve old timeout using embedded expect<br>!set user_namespace(TIMEOUT) $timeout<br># set timeout to 15 seconds - max time to wait for login prompts<br>@15<br>&gt;telnet $dut_ip<br>&lt;login<br>&gt;&gt;root<br>&lt;assword<br>&gt;&gt;my_secret<br>&gt;<br># Set the timeout back to old timeout<br>@$TIMEOUT<br></pre>
Expect-lite variable/values are stored in the tcl array
user_namespace()
with the variable name as the index name. Constants are stored
similarly in the tcl array cli_namespace().<br>
      <br>
Expect code is collected in <span style="font-style: italic;">islands</span>
and executed after an <span style="font-style: italic;">island
shore</span>
is reached. The <span style="font-style: italic;">island
shore</span>
is represented by lines that start with any <a href="#special_characters">special character</a>,
except '#' and blank
lines. However, it is recommended that the '&gt;' be used, as this
implies a "wait for prompt."<br>
      <br>
Branching and looping are supported in embedded expect e.g.:<br>
      <pre>!if { $arch == "ppc" } { <br>! puts "\narch is $arch\n"<br>!} <br>&gt;<br></pre>
And looping:<br>
      <pre>!for {set j 1} {$j&lt;6} {incr j} {<br>! if {$j == 1} {set type "abc" } <br>! if {$j == 2} {set type "def" }<br>! if {$j == 3} {set type "hij" }<br>! if {$j == 4} {set type "lmn" }<br>! if {$j == 5} {set type "qrs" }<br>! <br>! puts "$j&gt;$type"<br>!}<br>&gt;<br></pre>
Provides access to expect send &amp; expect commands:<br>
      <pre>!send "ls\n"<br>!expect -re "test" { puts "got test"} timeout {puts "got nothing"}<br></pre>
Embedded expect can fail the entire expect-lite script by calling the
built-in
_el_fail_test function:<br>
      <pre>!if { $arch == "ppc" } { <br>! puts "\narch IS $arch\n" <br>! } else { <br>! puts "\narch is NOT ppc, but $arch\n" <br>! _el_fail_test <br>! } <br>&gt;<br></pre>
TCL files can be sourced, and functions can be declared and called from
within embedded expect.<br>
      <br>
      <span style="font-weight: bold;"><a name="limitations_of_embedded_expect"></a>Limitations
of Embedded
Expect</span>:<br>
      <ul>
        <li>Limited support of expect global variables. To
declare a
variable
at the top level as global use "set ::&lt;var&gt;
&lt;value&gt;" The
double
colon '::' makes var global (this is a TCL standard)</li>
        <li>tcl/expect <span style="font-style: italic;">switch</span>
command not supported</li>
        <li>expect statements must be on one line (as in the
example
above)<br>
        </li>
      </ul>
      <br>
Please remember, this functionality is to provide assistance to
expect-lite
rather than replace it. (see <a href="#whats_missing">What's
Missing</a>)<br>
      <br>
      <h2><a name="directives"></a>Expect-lite Directives '*'<br>
      </h2>
Expect-lite directives are indicated by lines which start with the
asterisk, '*'. The directives change the behaviour of expect-lite in a
user defined manner. These directives include:<br>
      <ul>
        <li>fail script - run when the script fails
*~include_fail_script</li>
        <li>user defined prompt - for those non-unix/linux remote
hosts
*/regex/</li>
        <li>stopping the script - *TERM &amp; * FAIL</li>
        <li>setting the default shell - **SHELL</li>
        <li>multiple sessions - for hard to script environments
*FORK</li>
        <li>managing logging - *INFO, *NOINFO, *WARN, *NOWARN,
*DEBUG, *NODEBUG, *NOCOLOR</li>
        <li>debugging aid - *INTERACT (see <a href="./expect-lite_tips.html">debugging tips</a>)</li>
        <li>print all expect-lite variables - *SHOW VARS</li>
        <li>control end of line character(s) - *EOLS LF, *EOLS
CRLF</li>
      </ul>
Directives can also be placed on the command line at run time. This is
useful for controlling logging, such as *NOINFO or *NOCOLOUR.
Additionally, *NOFAIL can be useful when debugging a script, since the
script will not stop prematurely.<br>
      <h3><span style="font-weight: bold;"><a name="fail_script"></a></span>Fail
Script&nbsp;&nbsp;&nbsp; *~include_fail_script</h3>
The purpose of the fail script is to clean up after the failed script,
reseting times, deleting temporary files and such. It is a special
include script which is declared near the top of the script:<br>
      <pre>*~clean_up.inc</pre>
Should the script fail, the fail script will be "sourced".&nbsp;<br>
      <br>
The scope of the fail script is always local to the running script.
This allows normal include scripts to declare a separate fail script
from the main script. Thus enabling a different clean up mechanism for
the include script.<br>
      <br>
The fail script mechanism should no longer be needed&nbsp; for script
development. The technique was useful before debugging tools like
instant-interact and the powerful IDE built into version 4.0.1.<br>
      <br>
      <h3><a name="user_defined_prompt"></a>User
Defined Prompt&nbsp;&nbsp; */prompt/</h3>
With each '&gt;' command an implied "wait for prompt" occurs (see <a href="#implied_prompt">implementation details</a>).
The predefined
prompts are based on standard shell prompts (&gt;%$#). However, it
is
quite possible that expect-lite will not be interacting with a shell,
but another application (such as gdb) or device which does not issue a
shell-like prompt.<br>
      <br>
As of version 3.1.5, the user may define a custom prompt. User defined
prompts are defined from the newline (beginning of line) to the end of
the prompt. For example:<br>
      <pre>*/my_prompt /</pre>
The succeeding&nbsp; '&gt;' lines will interpret a prompt as
the
standard shell prompts and 'my_prompt '. The user defined prompt
definition between the slashes is interpreted as regex, and therefore
regex rules such as <a href="#escaped_regex">escaping</a>
applies. For
example, to set a user defined prompt for gdb the following would be
used:<br>
      <pre>*/\(gdb\) /</pre>
Only one (1) user defined prompt can&nbsp; be active at a time,
however
multiple prompts can be represented using the regex OR '|', for
example, creating a gdb prompt and my_prompt:<br>
      <pre>*/\(gdb\) |my_prompt /</pre>
Another application of the user defined prompt is to make telnet logins
easier:<br>
      <pre>*/login: |.+ssword: /<br>&gt;telnet remote-host-018<br>&lt;Connected to<br>&gt;$username<br>&gt;$password<br>&gt;<br></pre>
Clearing a user defined prompt. There may be times where a previously
user defined prompt is causing problems by output which falsely
triggers the user defined prompt. It is possible to clear the user
defined prompt by:<br>
      <pre>*//</pre>
Debug the user defined prompt by using the -vv or --verbose cli
parameter. In the example below, the user defined prompt has been
incorrectly */\(gbb\) / while running gdb (a linux debugger). The debug
output shows the user defined prompt and the string expect-lite is
searching for the prompt.<br>
      <pre>(gdb) Warning:Prompt Timed Out!<br>DEBUG: User Defined Prompt:&lt;&lt;\(gbb\) &gt;&gt;<br> Not Found in&lt;&lt;<br>(gdb) <br>&gt;&gt;</pre>
      <br>
The scope of the user defined prompt is global, that is, it extends to
the main script as well as all include files referenced.<br>
      <br>
      <h3><a name="directive_shell"></a>Setting
the
default shell with
**SHELL=&lt;shell&gt;</h3>
expect-lite
has been tested with bash, however it should operate with other shells.
Based on the user's preference, a shell can be selected with the
**SHELL directive. Because the shell is invoked immediately after login
to the remote host, this is a configuration directive with is read
before the script executes. Therefore, it can be placed anywhere in the
script, and is not limited to the first line.<br>
      <br>
      <h3><span style="font-weight: bold;"><a name="directive_term_fail"></a></span>Stopping
the script
early with *TERM, *PASS &amp; *FAIL</h3>
There
are times when it is desirable to terminate the execution of a script
early (earlier than the end of the script). For example, while
debugging a script, it is convenient to stop execution mid way in the
script while focusing a troublesome section. Or to perform a test, such
as this is Monday, and terminate the script.<br>
      <br>
*TERM (and *PASS) will stop
execution and return 0, or Pass. This is useful for debugging. *FAIL
will stop execution and return 1, or Fail. If a fail script has been
declared earlier, it will be executed before terminating execution.<br>
      <br>
      <h3><a name="directive_nofail"></a>No stopping the script with
*NOFAIL</h3>
There
are times, especially when debugging a script, where it is desirable to
not stop the script due to a failure, but instead allow the script to
run until completion. Setting the directive *NOFAIL will prevent the
script from terminating prematurely. Once invoked, there is no
disabling *NOFAIL. <br>
      <br>
Upon completion, if there are failures during the script, expect-lite
will return a 1, and indicate that there was a failure.<br>
      <br>
      <h3><span style="font-weight: bold;"><a name="directive_term_fail"></a></span>Debugging
by examining expect-lite variables with *SHOW VARS</h3>
It
can be useful when debugging a script to see what the value of
variables are at some point in the script. Additionally, overriding
constants will also be printed. This can be used with *INTERACT, or
pausing the script, however using the debugger command &lt;esc&gt;v is
less typing.<br>
      <br>
      <h3><a name="directive_fork"></a>Multiple
Sessions
*FORK</h3>
Until version release 3.5.0, expect-lite has been intentionally limited
to a single session keeping it simple. However, there are certain
environments where it might be advantageous for a single script to
control/monitor both a client (e.g wget) and a server (httpd log).
Without multiple session support this type of environment would be
difficult to automate with expect-lite.<br>
      <br>
What is a new session? A new session starts with a new shell on the <span style="font-style: italic;">remote host</span>. All
commands '&gt;'
and received text '&lt;' are constrained to that session. It is
possible to use multiple sessions on the localhost using r=none,
however <a href="expect-lite_install.html#connect_method">r=none
support is limited</a> due to timing issues. If multiple sessions
on the
localhost (the same host where expect-lite is running), it is better to
ssh to the localhost by specifying r=localhost. This <span style="font-style: italic;">loop back</span> method
ensures that the
timing between commands and received text stay in sync.<br>
      <br>
With the version of 3.5.0, expect-lite supports nearly limitless
multiple sessions. However, it is a good guideline to use as few
sessions as needed. For backward compatibility, the first session is
the
"default" session. Additional sessions are assigned a name at
invocation with the *FORK &lt;session_name&gt; directive:<br>
      <pre>*FORK Server<br>INFO: FORK session is: Server<br></pre>
expect-lite will print an "INFO" line stating the current session name<br>
Session names may not contain spaces, and must be unique for each
session. To switch back to a previously started session, re-use the
session name. The session name "default" (without quotes) is reserved
for the first session.<br>
      <pre>*FORK default<br>INFO: FORK session is: default<br></pre>
Print the current session name by using the *FORK with no session name:<br>
      <pre>*FORK<br>INFO: FORK session is: Server<br></pre>
*FORK and variables. It is possible to assign a session name to a
variable, and then create a new session with that name. For example:<br>
      <pre>$my_session=Client<br>*FORK $my_session<br>INFO: FORK session is: Client<br></pre>
All sessions will be automatically closed when the script terminates. <br>
      <br>
      <a name="directive_fork_debugging"></a>Debugging
in
a multi-session
environment: When in INTERACT, either via the *INTERACT command in the
script or via instant-interact (by pressing ^\), the *FORK command is
still available, permitting the switching of sessions while in INTERACT
mode. For example:<br>
      <pre>expect-lite directive: *INTERACT <br><br> Press '+++' to end interact session &amp; return to script <br><br>% *FORK CONSOLE<br><br>INFO: FORK session is: CONSOLE, Active sessions are: default CONSOLE<br># <br></pre>
      <br>
      <a name="directive_fork_single_threaded"></a>With
the addition of
multiple sessions, decoding the output will become
more difficult. Remember, although multiple sessions are supported,
expect-lite is still single threaded, meaning commands will always be
executed the order as they appear in the script.<br>
      <br>
      <h3><a name="directive_managing_logging"></a>Managing
Logging *INFO,
*NOINFO, *EXP_INFO, *NOEXP_INFO, *WARN, *NOWARN,
*DEBUG, *NODEBUG, *NOCOLOR</h3>
Expect-lite provides additional information (logging) which makes it
easier to debug failures. As of version 3.7.0, the output is coloured
based on three levels of logging: <span style="color: rgb(0, 153, 0);">info</span>,
      <span style="color: rgb(204, 153, 51);">warnings</span>,
and debug. By default, <span style="color: rgb(0, 153, 0);">info </span>and
      <span style="color: rgb(204, 153, 51);">warnings</span> are
turned on and <span style="color: rgb(0, 153, 0);">exp_info </span>is
turned off.&nbsp;
However, using the logging directives: *INFO, *NOINFO, *WARN, *NOWARN,
*DEBUG, *NODEBUG, these messages can be managed. Additionally,
*NOCOLOR, will turn off color output.<br>
      <br>
Example of the different logging levels are:<br>
      <ul>
        <li>INFO: Entering FORK sessions, Constant substitution,
Conditional
Statement Results, Jumping to labels, Including files, Dynamic Variable
Assignments, User Defined Prompt assignments and ##Overal Result.<br>
</li>
        <li>EXP_INFO: prints "expected" text (lines with &lt; or
&lt;&lt;). Also enabled with -V flag on the command line.</li>
        <li>WARN: Instant-Interact feature disabled,
Wait-for-prompt
timeouts, Using localhost (r=none), Unable to parse Conditional,
Dynamic Variable Capture timeouts, Unable to parse math variable
statement, Unable to parse FORK session name, Unable to parse
Conditional Statement</li>
        <li>DEBUG: Additional debugging information for: User
Defined
Prompt,
FORK session instantiation/switching,
'&lt;' searching, Dynamic Variable capture</li>
      </ul>
In addition to the Logging Directives, invoking expect-lite with a -v
or -vv will force INFO &amp; WARN on or WARN &amp; DEBUG on,
respectively. It should be possible to direct the amount of logging
desired by using a combination of&nbsp;the command line arguments
(-v
or -vv) and the Logging Directives.<br>
      <br>
In addition to the three logging levels above, there is another more
serious level of <span style="color: rgb(204, 0, 0);">ERROR</span>,
which can not be suppressed, and will terminate
expect-lite with a non-zero return code. Examples of <span style="color: rgb(204, 0, 0);">ERROR</span>s are:
unable
to connect or lost connection with remote host, include file not found,
bad timeout value (non-numeric) or infinite loop detection.<br>
      <br>
It may be tempting to turn off logging once a script is debugged.
However, if the script is being run in an automated environment (like
crontab), it is recommended that INFO and WARN be turned on, as the
additional information will make debugging failures much easier.<br>
      <br>
      <h3><a name="eols"></a>Controlling End
of Line Sequence with *EOLS</h3>
There
are some remote devices which require carriage return + line feed at
the end of each line sent. In past versions of expect-lite, only line
feed was appended to each '&gt;' or '&gt;&gt;' line. This
limitation
made it difficult to automate tasks with this class of remote devices.<br>
      <br>
With
version 3.7.0, the end of line sequence can be controlled with the
following expect-lite directives: *EOLS LF &amp; *EOLS CRLF. The
default is *EOLS LF.<br>
      <br>
These directives can be placed anywhere in
the script and the setting remains in effect until another *EOLS
directive is encountered. For example, enabling a script to control a
linux machine (using *EOLS LF), and later in the script controlling a
remote power-switch device (using *EOLS CRLF).<br>
      <br>
      <h2><a name="examples"></a>Examples of Expect-lite</h2>
Below are some examples to better illustrate what can be accomplished
with expect-lite:<br>
      <br>
Setting the IP address on a secondary interface of the remote host (be
sure to escape the dot's in the IP address)<br>
      <pre>$local_eth=eth1<br>$ip_addr=192\.168\.10\.2<br># change timeout value to 10 sec<br>@10<br>&gt;ifconfig $local_eth $ip_addr<br>#check to ensure that we set the right IP address<br>&gt;ifconfig<br>&lt;$ip_addr<br></pre>
Starting a telnet to another host<br>
      <pre>@2<br>&gt;telnet remote-host-018<br>&lt;Connected to<br>&lt;login<br>&gt;&gt;root<br>&lt;assword<br>&gt;&gt;secret_password<br># issue a command once logged in<br>&gt;pwd<br>&gt;^]<br>&gt;quit<br><br></pre>
Starting a ssh session to another host<br>
      <pre>&gt;ssh root@host-021<br>&lt;assword:<br>&gt;secret_password<br># issue a command once logged in<br>&gt;ls<br>&gt;exit<br><br></pre>
      <a name="screen_example"></a>Use of 'screen'
command
to keep a command
alive after test completes<br>
      <pre>; ==== Use Screen command for to keep application running ====<br>&gt;screen <br>&gt; $pmm <br># Check that HW is alive<br>&gt;ping<br>&lt;Successfully pinged the PM H/W<br>; ==== Keep pmm application active, and detach from this screen<br>&gt;&gt;^A<br>&gt;&gt;^D<br>&lt;detached<br>&gt;<br></pre>
      <a name="dyn_var_example"></a>Assigning a
dynamic
variable $host using
regex to capture the hostname
from 'uname -a' command<br>
      <pre>&gt;uname -a<br>+$host=Linux ([a-z\-0-9]+)<br>Assigned Var:host=remote-host-008<br>&gt;<br></pre>
Assigning multiple dynamic variables using regex to capture environment
variables $HOME and $SHELL, while expecting $TERM=xterm<br>
      <pre>&gt;env | sort<br>+$home=\nHOME=([a-z/]+)<br>+$shell=\nSHELL=([a-z/]+)<br>&lt;TERM=xterm<br>Assigned Var:home=/home/joe<br>Assigned Var:shell=/bin/bash<br>&gt;<br></pre>
Manage multiple Screen commands with a dynamic variable and regex
capture<br>
      <pre># show the last screen in the list <br>&gt;screen -list | grep pts | sort | tail -1<br># regex capture to dynamically assign the result to var $myscreen<br>+$myscreen=([0-9]+\.pts.[0-9]+.[a-z\- 0-9]+)<br># connect to $myscreen<br>&gt; screen -r $myscreen<br># inside existing screen, kick it to get a prompt<br>&gt;&gt;^M<br>&gt; sleep 3<br>&gt; ls<br>&gt;<br>&gt;&gt;^A<br>&gt;&gt;^D<br>&lt;detached<br>&gt;<br></pre>
Using Regex in expect-lite to allow multiple responses<br>
      <pre>&gt;id<br># allow either groups users or wheel<br>&lt;(users|wheel)<br></pre>
      <a name="temp_file_example"></a>Create a
temporary
file with unique
name including script name and date. The <a href="#predefined_variables">predefined variable</a>
$arg0 is contains
the expect-lite script name.<br>
      <pre># date stamp of script run time<br>&gt;echo `date +_%Y_%m_%d_%H-%M-%S`<br>+$DATE=\n(_[0-9_-]+)<br><br>$temp_file=$arg0$DATE<br>; === Create a temp file using bash "here doc" method<br>&gt;cat &gt; $temp_file &lt;&lt;'+++'<br>&gt;line 1<br>&gt;line 2<br>&gt;+++<br>&gt;<br></pre>
      <a name="script_help_example_old"></a>Creating script help. First, require a
parameter be passed via the CLI, such as sw_build:<br>
      <pre>./upgrade_script.elt sw_build=0015<br></pre>
Inside the script itself, default $sw_build to 0, the CLI constant will
override. <br>
      <pre>$sw_build=0000<br>; === Check passed parameters<br>&gt;<br>*NOINFO<br>?if $sw_build != 0000 ? %CONTINUE<br>	;; ##############################<br>	;;	$arg0 Requires parameters: sw_build, IP<br>	;;	e.g. $arg0 sw_build=0015 IP=10.3.5.4<br>	;; ##############################<br>	# quit the script without continuing<br>	*FAIL<br>%CONTINUE<br>*INFO<br><br></pre>
Now when just the script is executed, help will be displayed, and the
script will terminate.<br>
      <pre>./upgrade_script.elt<br><br><span style="color: rgb(51, 102, 255);"> === Check passed parameters</span><br><br><span style="color: rgb(0, 153, 0);">expect-lite directive: *NOINFO </span><br><span style="color: rgb(51, 102, 255);"> ##############################</span><br style="color: rgb(51, 102, 255);"><span style="color: rgb(51, 102, 255);"> upgrade_script.elt Requires parameters: sw_build, IP</span><br style="color: rgb(51, 102, 255);"><span style="color: rgb(51, 102, 255);"> e.g. upgrade_script.elt sw_build=0015 IP=10.3.5.4</span><br style="color: rgb(51, 102, 255);"><span style="color: rgb(51, 102, 255);"> ##############################</span><br><br><span style="color: rgb(0, 153, 0);">expect-lite directive: *FAIL </span><br><br></pre><a name="script_help_example"></a>As
of version 4.3.0, User defined help can make scripts more
user-friendly. Text between triple-semi-colons ';;;' will be displayed
when the -h or --help option is used on the command line<br>
      <pre>;;;<br>Test: 	Test bash here doc<br>		<br>Assumptions:	bash<br>Platforms: 	anywhere bash runs<br>;;;<br></pre>
Then running the script, the help text as well as variables&nbsp; in
the script which can be overridden on the command line (as constants).<br>
      <pre>$ ./test_bash_here_doc.txt -h<br><span style="color: rgb(0, 102, 0);">Help for: ./test_bash_here_doc.txt</span><br><br>        Test:   Test bash here doc<br><br>        Assumptions:    bash<br>        Platforms:      anywhere bash runs<br><br><span style="color: rgb(0, 102, 0);">Displaying assigned variables, which can be overridden with </span><br style="color: rgb(0, 102, 0);"><span style="color: rgb(0, 102, 0);">a Constant on command line e.g var=value</span><br>        tempfile=junk<br><br></pre>

      <h2><a name="test_failure"></a>Test
Failure?!?</h2>
When will expect-lite fail a test? It will only fail a test when an
expected result (after issuing a command) does not appear in the
specified timeout period. For example in the following command file:<br>
      <pre>$ip_addr=192.168.10.99<br>&gt;/sbin/ifconfig eth0 $ip_addr<br>&gt;/sbin/ifconfig eth0 <br>&lt; $ip_addr<br></pre>
The first line will be sent (blindly), since there is no expected
return. On line 3, the ifconfig command is sent again, and the script
is looking for a desired result of&nbsp; 192.168.10.99 (using the
var
$ip_addr). If for some reason the ip address is different than ip
address was returned, the script would fail.<br>
      <br>
      <span style="font-weight: bold;"><a name="not_expect"></a>Not
Expect</span><br>
A test can also fail should text appear that is unexpected (such as an
error). This does not clear the <a href="#expect_buffer">expect
input
buffer</a>,
and should be used before a valid expect. How long should the script
wait for the un-expected? In order to reduce delays in script running
time, the Not Expect feature only waits for <a href="#delay_wait_for_host">100ms</a>. This is usually
enough time to
detect quick error responses such as "file not found".&nbsp;<br>
      <br>
For example: Fail device doesn't exist <br>
      <pre>&gt;ls -l /dev/linux<br>-&lt;No such file<br></pre>
In another example: We don't like Mondays <br>
      <pre>; === fail if today is 'Monday'<br>&gt;date +%A<br>-&lt;Monday<br></pre>
Since the expect input buffer is not consumed, valid expects can still
be performed. in the following example, ttyS2 will still be found.<br>
      <pre>&gt;ls -1 /dev/ttyS*<br>-&lt;ttyX<br>&lt;ttyS2<br></pre>
It is recommended that <span style="font-style: italic;">Not
Expect </span>lines<span style="font-style: italic;"> </span>be used
before valid expect lines.<br>
      <br>
      <h2>How can it help?</h2>
Expect-lite can be used to quickly create automated tests. It can
collapse complicated tests into a single command line. It can also be
used in nightly regression testing, performing simple functional
tests providing confidence that core functionality has not been broken
by the previous day's submissions.<br>
      <br>
      <h2>Limitations</h2>
      <br>
Expect-lite is limited to what a person could do in one (1) terminal
window (or xterm). It cannot start a program in one window and run a
different program in a separate window. However it does
support multiple sessions via <a href="#directive_fork">*FORK</a>
which should meet the needs of most.&nbsp;&nbsp; <br>
      <br>
Standard programming constructs such as looping and branching are
supported as of version 3.0.0. Real Expect can do these things and
more. That said, looping
is limited to a repeat loop and while loop and branching can be accomplished with
Labels. <br>
      <br>
Expect-lite has been purposely limited to keep scripts simple, easy
to use and maintain. Although more complex scripts can be created,
basic expect-lite scripts can be created by simply cutting and pasting
text from a terminal window into a script and adding '&gt;'
'&lt;'
characters.<br>
      <br>
      <h2>Implementation Details</h2>
      <h3><a name="Variables"></a>Variables</h3>
Variable names must be restricted to the following set of characters
[A-Za-z0-9_]. Variable values may include spaces, and quoting is not
required nor permitted. For example:<br>
      <pre>$bell=For whom the bell tolls<br>&gt;echo $bell<br>For whom the bell tolls<br><br></pre>
      <h3><a name="implied_prompt"></a>Implied
"wait
for prompt"</h3>
Using the '&gt;' character implies waiting for the prompt before
sending the command. The definition of a shell prompt a: $, #, % or
&gt;. It is often useful to follow a '&lt;' with a
'&gt;' for force the script to wait for the prompt:<br>
      <pre>&gt; $some_long_command<br>&lt;critical value<br># wait for prompt<br>&gt;<br></pre>
Prompt detection can be problematic, and by no means is expect-lite's
method perfect. Expect-lite looks for a <span style="text-decoration: underline;">prompt character</span>
($, #, %
or
&gt;) <span style="text-decoration: underline;">followed
by a space</span>
at the <span style="text-decoration: underline;">end of
line</span>.
This should work for most standard prompts, however coloured or fancy
prompts may not be detected. As of
version 3.1.5, <a href="#user_defined_prompt">user
defined prompt</a>
is supported.<br>
      <br>
It may be useful to create files on the fly which will be used in the
test. Since expect-lite does not read/write files directly, this
function can be done with the linux command 'cat' and the <span style="font-style: italic;">bash here doc</span>
method. Creating a
regex
file for example:<br>
      <pre>; ==== Create Test File on the fly<br>&gt; cat &gt; $regex_test_file &lt;&lt; '+++'<br>&gt;T00001/a(?$XL.*)/tag=0x08000001<br>&gt;T00002/b(?$XR.*)/tag=0x08000002<br>&gt;T00003/c(?$XO[0-7]*)/tag=0x08000003<br>&gt;T00004/d(?$XH[0-9A-F]*)/tag=0x08000004<br>&gt;T00005/e(?$XD[0-9]*)/tag=0x08000005<br>&gt;+++<br>&gt;<br></pre>
In the above example the script initiates a cat to a file (referenced
by $regex_test_file ). Normally the '&gt;' would be used to send
lines
to the remote host. However, there is an inherent "wait for prompt",
which will politely wait for the next line. The last '&gt;' is
there to
wait for the prompt to return
after the cat command.<br>
      <br>
      <h3><a name="predefined_variables"></a>Predefined
variables</h3>
Expect-lite has minimized the use of predefined variables to allow the
user the widest latitude in selecting variable names. However a few
predefined variables are useful and listed below:<br>
      <table style="text-align: left; width: 80%;" border="1" cellpadding="2" cellspacing="2">
        <tbody>
          <tr>
            <td style="vertical-align: top; font-weight: bold;">Predefined
variable<br>
            </td>
            <td style="vertical-align: top; font-weight: bold;">Usage<br>
            </td>
          </tr>
          <tr>
            <td align="undefined" valign="undefined">$arg0</td>
            <td align="undefined" valign="undefined">expect-lite
script name.
Set to the c= or cmd_file= value. Useful for creating temporary files
unique to the test script.</td>
          </tr>
          <tr>
            <td align="undefined" valign="undefined">$timeout_multiplier</td>
            <td align="undefined" valign="undefined">Typically
used as a
constant (passed in from the command line) which the integer value is
multiplied by each of the timeouts in the script. i.e. @10 x
$timeout_multiplier = real timeout. The value default is 1.</td>
          </tr>
        </tbody>
      </table>
      <br>
      <h3><a name="zero_timeout"></a>Timeouts</h3>
Setting the expect-lite timeout to 0 isn't actually zero as this will
cause the keyboard input buffer on the remote machine to overflow (and
lose characters). Expect-lite adds a 50ms delay between lines when the
@0 is used to prevent the overflow.<br>
      <h3><a name="expect_buffer"></a>Expect
Input
Buffer<br>
      </h3>
Expect by default places strings that are sent back (from the remote
host) into an expect buffer ($expect_out(buffer)). Expect-lite
leverages this built in function, and uses it to perform multiple
searches through the buffer when using the '&lt;' , '+&lt;' or
'-&lt;'
actions. The actions '&gt;' and '&gt;&gt;' will clear
expect buffer to
prevent spurious matches.<br>
      <br>
      <h3><a name="delay_wait_for_host"></a>Timing
is everything:
delay_wait_for_host</h3>
When communicating with a remote host, enough time must be provided for
the remote host to respond. There is an internal global value of
$delay_wait_for_host (in mili-seconds) which can be tuned to your
environment using the environment variable EL_DELAY_WAIT_FOR_HOST (see
sample bashrc). This value is also used by the Expect Not feature to
determine how long Expect-Not should wait for the unexpected.<br>
      <br>
      <h3><a name="unsynchronized_messages"></a>Unsynchronized
messages
disclaimer</h3>
Effort has been put into making the output as synchronous as possible.
However because what is seen on stdout or screen is data
returned/echoed from the remote host and printable comments are
directly printed to stdout, it is possible to have a printable comment
appear in the stdout before the action it references is returned from
the remote host. This lack of synchronization can sometimes be
minimized by adding an additional '&gt;' after the printable
comment as
shown in the following:<br>
      <pre>; === starting long command<br>&gt;<br>&gt;start_long_command</pre>
      <br>
      <h3><span style="font-weight: bold;"><a name="instant-interact_explained"></a>Instant-Interact:
More than just
a pretty prompt</span></h3>
When the user presses ^\ (control+backslash) during the running of a
script, expect-lite will drop into interactive mode aka the integrated
debugger. In version 4.0.1, the debugger has been greatly enhanced and
performs three primary functions: 1) connecting the user to the remote
host or device under test, 2) monitoring special commands prefaced with
the escape key for stepping, and other functions, and 3) the debugger
will allow expect-lite script lines to be executed by either typing
directly or pasting them into the debugger. The TCL package TclX is no
longer required.<br>
      <br>
      <br>
Control will be returned to the script when '+++' is typed. In addition
to returning to the script, the current command in the script will be
"Passed", preventing it from failing the script. This is useful when
debugging a script, the user notices that the response is not as
expected, and presses ^\ to move to interact mode. Returning from
interact mode, the line which would have failed the script (because of
the response not being as expected) will be "Passed" and the script
will continue. This Passing action is line oriented, and other
'&lt;'
lines in the script can still fail the script.<br>
      <br>
      <a name="ide"></a>&nbsp;In the IDE (debugger), expect-lite
script commands can be typed, even assigning variables or displaying
them inside the
paused script, for example:<br>
      <pre>$MYVAR=today<br><br>*SHOW VARS<br>Var:0 Value:0<br>Var:MYVAR Value:today<br>Var:TEST Value:/proc/cpuinfo<br><br>&gt;&gt;pwd<br>pwd<br>/home/user</pre>
Additionally, expect-lite lines (code fragments) can be copied from
your favourite editor and pasted directly into the debugger. All
variables will be automatically dereferenced (assuming they were set in
the first place). This is very useful for testing Dynamic Variable
capture lines, which can be tricky to define.<br>
      <br>
      <a name="clumping"></a>When
lines are pasted into the debugger, or the Step or sKip function are
used, the debugger clumps lines which begin with '&gt;' and any
following lines with start with '&lt;' or '+$' This enables expected
results and dynamic variables to be interpretted correctly. For example:<br>
      <pre># clump 1<br>&gt;ls /etc/<br>&lt;group<br>&lt;passwd<br><br>#clump 2<br>&gt;date "+TIME: %H:%M:%S"<br>+$time=\nTIME: ([0-9:]+)</pre>
If
the above lines are copied and pasted into the debugger, in fact they
will be executed as 2 clumps. Usually this is of no concern, however
when stepping/skipping through an expect-lite script, one will notice
that clumps are executed rather than indivdual lines.<br>
      <br>
      <h3><a name="fork_explained">*FORK: what
happens
behind the scenes<br>
      </a></h3>
A new *FORK session actually creates an additional login(s) to the
remote host from the localhost using the same connect method as the
first (or default) session. It then sets a sane prompt, and waits for
the first script command in that session. This provides multiple
sessions on the remote host, which then could be used to drive separate
programs (see test_fork_web_client_server.txt for example). Graphically
it would appear as:<br>
      <pre>Localhost Remote Host<br> +----New_Session1---&gt;Client App<br> +----New_Session2---&gt;Server App<br></pre>
      <br>
      <h2><a name="whats_missing"></a>What's
missing</h2>
In order to maintain an easy-to-learn, simple-to-use expect like
language, looping has been intentionally kept simple and intuitive.
Most expect-lite scripts will be to be top down, single pass scripts,
making the scripts easy to create and read. These limitations preserve
the KISS principle.<br>
      <br>
If more complexity is required, consider using embedded expect inside
expect-lite, or writing a native expect script.<br>
      <h2>Why Expect-lite</h2>
Expect-lite was written so you don't have to learn expect. It provides
a quick way to write
simple expect scripts using just the &gt; and &lt; characters.<br>
      <br>
      <br>
<!--- End of Right Column Content ---> </td>
    </tr>
  </tbody>
</table>

<hr style="width: 100%; height: 2px;"><span style="font-style: italic;">13 February 2012<br>
</span><a href="http://expect-lite.sourceforge.net/"><small>http://expect-lite.sourceforge.net/</small></a><span style="font-style: italic;"><br>
</span><br>

<small><a href="https://lists.sourceforge.net/lists/listinfo/expect-lite-users">Subscribe
to expect-list-users</a> Discussion List</small><br>

<br>

<small><span style="font-style: italic;">this
document for version 4.3.0 and above</span><br style="font-style: italic;">
</small>
<br>

</body></html>