#!/usr/bin/env expect-lite
# make this puppy run


; === set expect buffer big
!match_max -d 1000
@2
$dummy_var= this   is just to   show a var abcdefghijklmnopqrstuvwxyz
$joe=dude
$user=bob
#*LOGAPPEND



>echo "hello&$user&there"
>echo $var

>


# Define Additional Functions
!proc mark_time { var_name } {
!	# A Procedure that marks current time in milliseconds and, updates expect-lite variable
!	set time [clock clicks -milliseconds ]
!	set ::expectlite::user_namespace($var_name) $time
!}


!proc show_time { var_time_ms var_date} {
!	# A Procedure that converts time from milliseconds and, updates expect-lite variable
!	set date $::expectlite::user_namespace($var_time_ms)
!	set ms [expr $date % 1000]
!	set date [expr int($date / 1000)]
!	set date_str [clock format $date -format "%Y-%m-%d %H:%M:%S"]
!	set date_str "$date_str.$ms"
!	set ::expectlite::user_namespace($var_date) $date_str
!}

# Define Additional Functions
!proc compare_fuzz { x value fuzz var_name } {
!	# A Procedure that checks value is in range and, updates expect-lite variable
!	# 	returns var_name=1 if in range, 0 if outside of range
!	set result 1
!	if { $x > [expr $value + $fuzz] } {set result 0}
!	if { $x < [expr $value - $fuzz] } {set result 0}
!	set ::expectlite::user_namespace($var_name) $result
!}


# Define Additional Functions
!proc fuzz_exp { str } {
!	set fuzz 5
!	# A Procedure that does a fuzzy expect
!	regsub "(.*)\((.*)" $str "\1" str_first
!	regsub "(.*)\)(.*)" $str "\2" str_last
!	regsub "(.*)\(.*\)(.*)" $str "\2" str_fuzz
!
!	# how to create expect line, with text(\d+)more text
!	# compare captured number to fuzzy range
!
!
!
!
!

!	expect  -re $str { return } timeout { puts "\n\tExpect Failed:$str"; _el_fail_test }

!}





# must define this var before using with TCL functions
$mytime1=0
$mytime2=0
$mydate=

!mark_time mytime1
>pwd
!mark_time mytime2
>pwd
!show_time mytime1 mydate
# calculate elapsed time
=$mytime2 - $mytime1
>
; == my date is:$mydate and time was:$mytime1
; == elapsed time is: $mytime2 ms
>

;cyan === fuzz testing

>date '+%S'
+$secs=\n(\d+)
>
$result=now
; first half of minute
!compare_fuzz $secs 15 15 result
>
; === show result:$result
?if $result == 1? ;green $secs is in first half :: ;red $secs is in second half
>

; === test fuzzy expect
~=5

>MIN=$(date '+%S')
#>MIN=15
>echo "this is the $MIN to rise up"
~<this is the ( 10 ) to rise up
>
>
>echo "bbbb is the $MIN to rise up"
~<bbbb (is) the ((10)) to rise up

>echo "cccc is the $MIN"
~<cccc is the (10)
>
>echo "eeee is the $MIN to rise up"
~<eeee (is) the no number to rise up

>echo "ffff is the 0xbeef to rise up"
~<ffff is the (0xbeea) to rise up
>
>echo "gggg is the $MIN"
~<(10.5)


*INTERACT
>
*TERM


# fail script
#*~self_test_fail_script.txt

>echo "hello ken"\
<ken
>
>echo "$dummy_var"
+$var=\n(.+)
>
>echo "$dummy_var"
+$var=\n((\w+ )+)
>
; === look for longer text
$prompt=$ 
>cat /etc/passwd 
+$regList=\n((.|\n|\r)*)\$ 
>

; === look multiple captures
$prompt=$ 
>cat /etc/passwd 
+$var1=\n(www-data.*$)
+$var2=\n(avahi.*$)
>



*INTERACT
>


*TERM

$x=1 
$y=2 
; ==== $xABC$y 

*INTERACT

*PASS

~show_vars.inc zamaze=15 dummy_var=override_this joe=$user
>echo "hello"
<\nhello
>
*SHOW VARS
>
*PASS


#~/home/cvmiller/Expect-lite/junk
#~xyz.inc

$EL_jtag=	\
?if $EL_jtag == ? $jtag=192.168.1.100 :: $jtag=$EL_jtag

>ifconfig
# get IP address of loopback interface
<lo
+$ip_addr=inet addr:([0-9.]+)
+$ip_addr2=inet addr:(\d+)

; === test var
$blank=
#?if [ info exist $TEST ] ? ; === echo this :: ; === echo that
?if $TEST ==  ? ; === echo this :: ; === echo that
?if$TEST==? ; === echo this :: ; === echo that
?if $TEST ==$blank? ; === echo this :: ; === echo that
?if$JOE==$BLOW? ; === echo this :: ; === echo that
>
*SHOW VARS
$val=50
>
?if 40 < $val && $val < 60 ? ; it works :: ; NO GO
?if 40 < $val < 60 ? ; it works :: ; NO GO
>
$i=0
[ $i < 3
	>echo "hello ken"
	<ken
	$j=0
	[ $j < 2 
		>echo "bye now"
		>
		+$j
	]
	+$i
]
*INFINITE_LOOP 5
; == blank condition
[ < 3
>echo "blank"
]


>
*INTERACT

; show this \
>

# ; === Sudo stuff
# # set user defined prompt line
# */.+: $/
# 
# #*NOINFO
# >sudo cat /etc/resolv.conf
# +$challenge=[Pp](assword) for
# ?if $challenge == assword ? >>$EL_rootpass
# 
# >
# *INTERACT
# >
# 
# #!expect -re "assword" { send $EL_rootpass } timeout {puts "=====>Lost it"}
# #!stty -echo; send  $EL_rootpass ; stty echo
